<!-- Charles Justin Reusnow • 25 August 2017 • CMP SCI 4500 • Homework 1 -->

<!DOCTYPE html>
<html>
<head>
    <title>A Pretty Strange Game</title>
    <style>
        #play-new-game-button {
            background-color: #dddddd;
            border: 3px solid black;
            padding: 16px 32px;
            text-align: center;
            text-decoration: none;
            display: block;
            font-size: 14px;
            font-weight: bolder;

            margin: 25px auto;
        }

        #results-wrapper {
            font-family: Consolas, serif;
            text-align: center;
            margin-left: auto;
            margin-right: auto;
        }

        #results-table, #results-table tr, #results-table tr th, #results-table tr td {
            padding: 10px;
            border: 3px solid black;
            border-collapse: collapse;
            background-color: #dddddd;
        }
    </style>
    <script>
        // Charles Justin Reusnow • 25 August 2017 • CMP SCI 4500 • Homework 1

        //TODO Opening Comment

        "use strict";

        const EMPTY_GRID = [];
        const EMPTY_ROW = [];
        const EMPTY_COLUMN = 0;

        const ROW_QUANTITY = 10;
        const COLUMN_QUANTITY = 10;

        const MINIMUM_ROW_INDEX = 0;
        const MAXIMUM_ROW_INDEX = ROW_QUANTITY - 1;
        const MINIMUM_COLUMN_INDEX = 0;
        const MAXIMUM_COLUMN_INDEX = COLUMN_QUANTITY - 1;

        const MAXIMUM_TOUCHES_ALLOWED = 1000000;

        const MARKER_STARTING_ROW = MAXIMUM_ROW_INDEX;
        const MARKER_STARTING_COLUMN = 0;

        const MARKER_END_GAME_ROW = 0;
        const MARKER_END_GAME_COLUMN = MAXIMUM_COLUMN_INDEX;

        const DIRECTION_LEFT = 0;
        const DIRECTION_UP = 1;
        const DIRECTION_RIGHT = 2;
        const DIRECTION_DOWN = 3;
        const DIRECTIONS = [DIRECTION_LEFT, DIRECTION_UP, DIRECTION_RIGHT, DIRECTION_DOWN];
        const DIRECTION_QUANTITY = DIRECTIONS.length;

        const DISTANCE_ZERO = 0;
        const DISTANCE_ONE = 1;
        const DISTANCE_TWO = 2;
        const DISTANCES = [DISTANCE_ZERO, DISTANCE_ONE, DISTANCE_TWO];
        const DISTANCE_QUANTITY = DISTANCES.length;

        const GAME_SUCCESS = true;
        const GAME_FAILURE = false;

        const EMPTY_GAME = {
            "grid": undefined,
            "marker": {
                "position": {
                    "row": undefined,
                    "column": undefined
                }
            },
            "touches": 0,
            "results": {
                "maximumTouches": undefined,
                "minimumTouches": undefined,
                "averageTouchesPerCell": undefined,
                "outcome": undefined,
                "totalTouches": undefined
            }
        };

        const EMPTY_MOVE = {
            "direction": undefined,
            "distance": undefined
        };

        const EMPTY_POSITION = {
            "row": undefined,
            "column": undefined
        };

        let game = undefined;

        /**
         * Purpose:
         * Inputs: None.
         * Output: None.
         * Assumptions:
         * */
        function playNewGame() {
            resetGame();
            setupGame();
            playGame();
            calculateResults();
            printResults();
        }

        /**
         * Purpose:
         * Inputs: None.
         * Output: None.
         * Assumptions:
         * */
        function resetGame() {
            game = deepCopy(EMPTY_GAME);
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function deepCopy(object) {
            return JSON.parse(JSON.stringify(object));
        }

        /**
         * Purpose:
         * Inputs: None.
         * Output: None.
         * Assumptions:
         * */
        function setupGame() {
            createGrid(ROW_QUANTITY, COLUMN_QUANTITY);
            placeMarkerAndRecordTouchAt(MARKER_STARTING_ROW, MARKER_STARTING_COLUMN);
        }

        /**
         * Purpose:
         * Inputs:
         * * rowQuantity - The number of rows to put in this grid.
         * * columnQuantity - The number of columns to put in this grid.
         * Output: grid - The newly created grid.
         * Assumptions:
         * */
        function createGrid(rowQuantity, columnQuantity) {
            resetGrid();
            addRowsAndColumnsToGrid(rowQuantity, columnQuantity);
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function resetGrid() {
            game.grid = deepCopy(EMPTY_GRID);
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function addRowsAndColumnsToGrid(rowQuantity, columnQuantity) {
            for (let rowIndex = 0; rowIndex < rowQuantity; rowIndex++) {
                addNewRow();
                addColumnsToRow(rowIndex, columnQuantity);
            }
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function addNewRow() {
            game.grid.push(deepCopy(EMPTY_ROW));
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function addColumnsToRow(rowIndex, columnQuantity) {
            for (let columnIndex = 0; columnIndex < columnQuantity; columnIndex++) {
                addNewColumnToRow(rowIndex);
            }
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function addNewColumnToRow(rowIndex) {
            game.grid[rowIndex].push(deepCopy(EMPTY_COLUMN));
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function placeMarkerAndRecordTouchAt(row, column) {
            placeMarkerAt(row, column);
            recordTouchAt(row, column);
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function placeMarkerAt(row, column) {
            game.marker.position.row = row;
            game.marker.position.column = column;
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function recordTouchAt(row, column) {
            incrementTotalTouches();
            incrementTouchCountAt(row, column);
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function incrementTotalTouches() {
            game.touches++;
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function incrementTouchCountAt(row, column) {
            game.grid[row][column]++;
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function playGame() {
            while (shouldContinuePlayingGame()) {
                continuePlayingGame();
            }
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function shouldContinuePlayingGame() {
            return !gameIsWon() && !gameIsBeyondMaximumTouches();
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function gameIsWon() {
            return markerIsInWinningPosition();
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function markerIsInWinningPosition() {
            return markerIsInWinningRow() && markerIsInWinningColumn();
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function markerIsInWinningRow() {
            return game.marker.position.row === MARKER_END_GAME_ROW;
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function markerIsInWinningColumn() {
            return game.marker.position.column === MARKER_END_GAME_COLUMN;
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function gameIsBeyondMaximumTouches() {
            return game.touches >= MAXIMUM_TOUCHES_ALLOWED;
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function continuePlayingGame() {
            let move = generateRandomMove();
            let originalMarkerLocation = deepCopy(game.marker.position);

            if (thisMoveDoesNotPutMarkerOutsideOfGrid(move)) {
                placeMarkerAtPositionFromMove(move);
            } else {
                placeMarkerAtOriginalLocation(originalMarkerLocation);
            }
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function generateRandomMove() {
            let move = deepCopy(EMPTY_MOVE);

            move.direction = generateRandomDirection();
            move.distance = generateRandomDistance();

            return move;
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function generateRandomDirection() {
            return DIRECTIONS[getRandomIntegerBetween(0, DIRECTION_QUANTITY)];
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function getRandomIntegerBetween(lowerBound, upperBound) {
            return lowerBound + Math.floor(Math.random() * upperBound)
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function generateRandomDistance() {
            return DISTANCES[getRandomIntegerBetween(0, DISTANCE_QUANTITY)];
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function thisMoveDoesNotPutMarkerOutsideOfGrid(move) {
            let potentialNewMarkerPosition = getMarkerPositionAfterThisMove(move);

            return positionIsWithinGrid(potentialNewMarkerPosition);
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function positionIsWithinGrid(position) {
            return positionIsWithinLeftBound(position) && positionIsWithinTopBound(position) && positionIsWithinRightBound(position) && positionIsWithinBottomBound(position);
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function positionIsWithinLeftBound(position) {
            return position.column >= MINIMUM_COLUMN_INDEX;
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function positionIsWithinTopBound(position) {
            return position.row >= MINIMUM_ROW_INDEX;
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function positionIsWithinRightBound(position) {
            return position.column <= MAXIMUM_COLUMN_INDEX;
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function positionIsWithinBottomBound(position) {
            return position.row <= MAXIMUM_ROW_INDEX;
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function getMarkerPositionAfterThisMove(move) {
            let markerPositionAfterThisMove = deepCopy(EMPTY_POSITION);

            switch (move.direction) {
                case DIRECTION_LEFT:
                    markerPositionAfterThisMove.row = game.marker.position.row - getMoveDistance(move);
                    markerPositionAfterThisMove.column = game.marker.position.column;
                    break;
                case DIRECTION_UP:
                    markerPositionAfterThisMove.row = game.marker.position.row;
                    markerPositionAfterThisMove.column = game.marker.position.column - getMoveDistance(move);
                    break;
                case DIRECTION_RIGHT:
                    markerPositionAfterThisMove.row = game.marker.position.row + getMoveDistance(move);
                    markerPositionAfterThisMove.column = game.marker.position.column;
                    break;
                case DIRECTION_DOWN:
                    markerPositionAfterThisMove.row = game.marker.position.row;
                    markerPositionAfterThisMove.column = game.marker.position.column + getMoveDistance(move);
                    break;
                default:
                    throw new Error("Unrecognized move direction encountered: \"" + move.direction + "\".");
            }

            return markerPositionAfterThisMove;
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function getMoveDistance(move) {
            let distance = undefined;

            switch (move.distance) {
                case DISTANCE_ZERO:
                    distance = 0;
                    break;
                case DISTANCE_ONE:
                    distance = 1;
                    break;
                case DISTANCE_TWO:
                    distance = 2;
                    break;
                default:
                    throw new Error("Unrecognized move distance encountered: \"" + move.distance + "\".");
            }

            return distance;
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function placeMarkerAtPositionFromMove(move) {
            let newMarkerPosition = getMarkerPositionAfterThisMove(move);
            placeMarkerAndRecordTouchAt(newMarkerPosition.row, newMarkerPosition.column);
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function placeMarkerAtOriginalLocation(originalMarkerLocation) {
            placeMarkerAndRecordTouchAt(originalMarkerLocation.row, originalMarkerLocation.column);
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function calculateResults() {
            calculateOutcome();
            calculateMaximumTouches();
            calculateMinimumTouches();
            calculateAverageTouchesPerCell();
            calculateTotalTouches();
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function calculateOutcome() {
            if (gameIsWon()) {
                game.results.outcome = GAME_SUCCESS
            } else if (gameIsBeyondMaximumTouches()) {
                game.results.outcome = GAME_FAILURE
            } else {
                throw new Error("Unexpected end of game encountered.");
            }
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function calculateMaximumTouches() {
            game.results.maximumTouches = findMaximumTouchesInGrid();
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function findMaximumTouchesInGrid() {
            let maximumTouchedInGrid = 0;

            game.grid.forEach(
                (row) => {
                    row.forEach(
                        (touchesInCell) => {
                            if (touchesInCell > maximumTouchedInGrid) {
                                maximumTouchedInGrid = touchesInCell;
                            }
                        }
                    );
                }
            );

            return maximumTouchedInGrid;
        }


        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function calculateMinimumTouches() {
            game.results.minimumTouches = findMinimumTouchesInGrid();
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function findMinimumTouchesInGrid() {
            let minimumTouchedInGrid = MAXIMUM_TOUCHES_ALLOWED;

            game.grid.forEach(
                (row) => {
                    row.forEach(
                        (touchesInCell) => {
                            if (touchesInCell < minimumTouchedInGrid) {
                                minimumTouchedInGrid = touchesInCell;
                            }
                        }
                    );
                }
            );

            return minimumTouchedInGrid;
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function calculateAverageTouchesPerCell() {
            game.results.averageTouchesPerCell = findAverageTouchesPerCellInGrid();
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function findAverageTouchesPerCellInGrid() {
            let totalTouches = 0;

            game.grid.forEach(
                (row) => {
                    row.forEach(
                        (touchesInCell) => {
                            totalTouches += touchesInCell;
                        }
                    );
                }
            );

            return (totalTouches / (ROW_QUANTITY * COLUMN_QUANTITY)).toFixed(2);
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function calculateTotalTouches() {
            game.results.totalTouches = game.touches;
        }

        /**
         * Purpose:
         * Inputs:
         * Output:
         * Assumptions:
         * */
        function printResults() {
            document.getElementById("results-wrapper").innerHTML = `
                    <table id="results-table" align="center">
                        <tr>
                            <th colspan="2">Results</th>
                        </tr>
                        <tr>
                            <th>Type</th>
                            <th>Value</th>
                        </tr>
                        <tr>
                            <td>Outcome</td>
                            <td>` + (game.results.outcome === GAME_SUCCESS ? `The marker is now in the correct position.` : `The game surpassed the maximum amount of turns allowed and failed to push the marker to the correct position.`) + `</td>
                        </tr>
                        <tr>
                            <td>Maximum Touches in a Cell</td>
                            <td>` + game.results.maximumTouches + `</td>
                        </tr>
                        <tr>
                            <td>Minimum Touches in a Cell</td>
                            <td>` + game.results.minimumTouches + `</td>
                        </tr>
                        <tr>
                            <td>Average Touches per Cell</td>
                            <td>` + game.results.averageTouchesPerCell + `</td>
                        </tr>
                        <tr>
                            <td>Total Touches</td>
                            <td>` + game.results.totalTouches + `</td>
                        </tr>
                    </table>
            `;
        }
    </script>
</head>
<body>
<button id="play-new-game-button" onClick="playNewGame();">Play New Game</button>
<div id="results-wrapper">
</div>
</body>
</html>